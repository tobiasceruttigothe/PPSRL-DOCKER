<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/org/paper/entity/Diseno.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/paper/entity/Diseno.java" />
              <option name="originalContent" value="package org.paper.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;@Data @NoArgsConstructor @AllArgsConstructor&#10;@Entity @Table(name = &quot;disenos&quot;)&#10;public class Diseno {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Integer id;&#10;&#10;    @ManyToOne(optional = false)&#10;    @JoinColumn(name = &quot;usuario_id&quot;, columnDefinition = &quot;uuid&quot;)&#10;    private Usuario usuario;&#10;&#10;&#10;    @ManyToOne(optional = false)&#10;    @JoinColumn(name = &quot;plantilla_id&quot;)&#10;    private Plantilla plantilla;&#10;&#10;    @Column(nullable = false, length = 100)&#10;    private String nombre;&#10;&#10;    @Column(columnDefinition = &quot;TEXT&quot;)&#10;    private String descripcion;&#10;&#10;    // Guardar como TEXT para evitar problemas de stream con Clob/Lob&#10;    @Column(name = &quot;base64_diseno&quot;, nullable = false, columnDefinition = &quot;text&quot;)&#10;    private String base64Diseno;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;estado&quot;,nullable = false, length = 20)&#10;    private DisenoStatus status = DisenoStatus.PROGRESO;&#10;&#10;    @Column(name = &quot;fecha_creacion&quot;, nullable = false)&#10;    private LocalDateTime fechaCreacion = LocalDateTime.now();&#10;&#10;    @Column(name = &quot;fecha_actualizacion&quot;)&#10;    private LocalDateTime fechaActualizacion;&#10;}&#10;" />
              <option name="updatedContent" value="package org.paper.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;@Data @NoArgsConstructor @AllArgsConstructor&#10;@Entity @Table(name = &quot;disenos&quot;)&#10;public class Diseno {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Integer id;&#10;&#10;    @ManyToOne(optional = false)&#10;    @JoinColumn(name = &quot;usuario_id&quot;, columnDefinition = &quot;uuid&quot;)&#10;    private Usuario usuario;&#10;&#10;&#10;    @ManyToOne(optional = false)&#10;    @JoinColumn(name = &quot;plantilla_id&quot;)&#10;    private Plantilla plantilla;&#10;&#10;    @Column(nullable = false, length = 100)&#10;    private String nombre;&#10;&#10;    @Column(columnDefinition = &quot;TEXT&quot;)&#10;    private String descripcion;&#10;&#10;    // Guardar como TEXT para evitar problemas de stream con Clob/Lob&#10;    @Column(name = &quot;base64_diseno&quot;, nullable = false, columnDefinition = &quot;text&quot;)&#10;    private String base64Diseno;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;estado&quot;,nullable = false, length = 20)&#10;    private DisenoStatus status = DisenoStatus.PROGRESO;&#10;&#10;    @Column(name = &quot;fecha_creacion&quot;, nullable = false)&#10;    private LocalDateTime fechaCreacion = LocalDateTime.now();&#10;&#10;    @Column(name = &quot;fecha_actualizacion&quot;)&#10;    private LocalDateTime fechaActualizacion;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/paper/entity/Logo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/paper/entity/Logo.java" />
              <option name="originalContent" value="package org.paper.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@EqualsAndHashCode(onlyExplicitlyIncluded = true)&#10;@ToString(exclude = &quot;usuario&quot;)&#10;@Entity&#10;@Table(name = &quot;logos&quot;)&#10;public class Logo {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    @EqualsAndHashCode.Include&#10;    private Integer id;&#10;&#10;    @ManyToOne(optional = false)&#10;    @JoinColumn(name = &quot;usuario_id&quot;, columnDefinition = &quot;uuid&quot;)&#10;    private Usuario usuario;&#10;&#10;    @Column(nullable = false, length = 100)&#10;    private String nombre;&#10;&#10;    @Lob&#10;    @Column(name = &quot;base64_logo&quot;, nullable = false)&#10;    private String base64Logo;&#10;&#10;    @Column(name = &quot;fecha_creacion&quot;, nullable = false)&#10;    private LocalDateTime fechaCreacion = LocalDateTime.now();&#10;&#10;    @Column(name = &quot;tamano_bytes&quot;)&#10;    private Long tamanoBytes;&#10;}&#10;" />
              <option name="updatedContent" value="package org.paper.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@EqualsAndHashCode(onlyExplicitlyIncluded = true)&#10;@ToString(exclude = &quot;usuario&quot;)&#10;@Entity&#10;@Table(name = &quot;logos&quot;)&#10;public class Logo {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    @EqualsAndHashCode.Include&#10;    private Integer id;&#10;&#10;    @ManyToOne(optional = false)&#10;    @JoinColumn(name = &quot;usuario_id&quot;, columnDefinition = &quot;uuid&quot;)&#10;    private Usuario usuario;&#10;&#10;    @Column(nullable = false, length = 100)&#10;    private String nombre;&#10;&#10;    @Lob&#10;    @Column(name = &quot;base64_logo&quot;, nullable = false)&#10;    private String base64Logo;&#10;&#10;    @Column(name = &quot;fecha_creacion&quot;, nullable = false)&#10;    private LocalDateTime fechaCreacion = LocalDateTime.now();&#10;&#10;    @Column(name = &quot;tamano_bytes&quot;)&#10;    private Long tamanoBytes;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/paper/entity/Plantilla.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/paper/entity/Plantilla.java" />
              <option name="originalContent" value="package org.paper.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;import java.time.LocalDateTime;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;@Getter @Setter&#10;@NoArgsConstructor &#10;@AllArgsConstructor&#10;@EqualsAndHashCode(onlyExplicitlyIncluded = true)&#10;@ToString(exclude = &quot;usuariosHabilitados&quot;)&#10;@Entity @Table(name = &quot;plantillas&quot;)&#10;public class Plantilla {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    @EqualsAndHashCode.Include&#10;    private Integer id;&#10;&#10;    @Column(nullable = false, length = 100)&#10;    private String nombre;&#10;&#10;    @ManyToOne(optional = false) @JoinColumn(name = &quot;material_id&quot;)&#10;    private Material material;&#10;&#10;    @ManyToOne(optional = false) @JoinColumn(name = &quot;tipo_bolsa_id&quot;)&#10;    private TipoBolsa tipoBolsa;&#10;&#10;    @Lob&#10;    @Column(name = &quot;base64_plantilla&quot;, nullable = false)&#10;    private String base64Plantilla;&#10;&#10;    @Column(name = &quot;ancho&quot;,nullable = false)&#10;    private Float ancho;&#10;&#10;    @Column(name = &quot;alto&quot;, nullable = false)&#10;    private Float alto;&#10;&#10;    @Column(name = &quot;profundidad&quot;,nullable = false)&#10;    private  Float profundidad;&#10;&#10;    @ManyToMany(mappedBy = &quot;plantillasHabilitadas&quot;)&#10;    private Set&lt;Usuario&gt; usuariosHabilitados = new HashSet&lt;&gt;();&#10;}&#10;" />
              <option name="updatedContent" value="package org.paper.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;import java.time.LocalDateTime;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;@Getter @Setter&#10;@NoArgsConstructor &#10;@AllArgsConstructor&#10;@EqualsAndHashCode(onlyExplicitlyIncluded = true)&#10;@ToString(exclude = &quot;usuariosHabilitados&quot;)&#10;@Entity @Table(name = &quot;plantillas&quot;)&#10;public class Plantilla {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    @EqualsAndHashCode.Include&#10;    private Integer id;&#10;&#10;    @Column(nullable = false, length = 100)&#10;    private String nombre;&#10;&#10;    @ManyToOne(optional = false) @JoinColumn(name = &quot;material_id&quot;)&#10;    private Material material;&#10;&#10;    @ManyToOne(optional = false) @JoinColumn(name = &quot;tipo_bolsa_id&quot;)&#10;    private TipoBolsa tipoBolsa;&#10;&#10;    @Lob&#10;    @Column(name = &quot;base64_plantilla&quot;, nullable = false)&#10;    private String base64Plantilla;&#10;&#10;    @Column(name = &quot;ancho&quot;,nullable = false)&#10;    private Float ancho;&#10;&#10;    @Column(name = &quot;alto&quot;, nullable = false)&#10;    private Float alto;&#10;&#10;    @Column(name = &quot;profundidad&quot;,nullable = false)&#10;    private  Float profundidad;&#10;&#10;    @ManyToMany(mappedBy = &quot;plantillasHabilitadas&quot;)&#10;    private Set&lt;Usuario&gt; usuariosHabilitados = new HashSet&lt;&gt;();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/paper/service/DisenoService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/paper/service/DisenoService.java" />
              <option name="originalContent" value="package org.paper.service;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.paper.dtoCreate.DisenoCreateDto;&#10;import org.paper.dtoCreate.DisenoUpdateDto;&#10;import org.paper.dtoResponse.DisenoResponseDto;&#10;import org.paper.dtoResponse.DisenoSimpleDto;&#10;import org.paper.entity.Diseno;&#10;import org.paper.entity.DisenoStatus;&#10;import org.paper.entity.Plantilla;&#10;import org.paper.entity.Usuario;&#10;import org.paper.exception.EntityNotFoundException;&#10;import org.paper.exception.InvalidStateException;&#10;import org.paper.exception.UnauthorizedAccessException;&#10;import org.paper.repository.DisenoRepository;&#10;import org.paper.repository.PlantillaRepository;&#10;import org.paper.repository.UsuarioRepository;&#10;import org.paper.util.Base64ValidatorUtil;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;public class DisenoService {&#10;&#10;    private final DisenoRepository disenoRepository;&#10;    private final UsuarioRepository usuarioRepository;&#10;    private final PlantillaRepository plantillaRepository;&#10;    private final Base64ValidatorUtil base64Validator;&#10;&#10;    public DisenoService(DisenoRepository disenoRepository,&#10;                         UsuarioRepository usuarioRepository,&#10;                         PlantillaRepository plantillaRepository,&#10;                         Base64ValidatorUtil base64Validator) {&#10;        this.disenoRepository = disenoRepository;&#10;        this.usuarioRepository = usuarioRepository;&#10;        this.plantillaRepository = plantillaRepository;&#10;        this.base64Validator = base64Validator;&#10;    }&#10;&#10;    /**&#10;     * Obtiene todos los diseños (sin base64 para optimizar)&#10;     */&#10;    public List&lt;DisenoSimpleDto&gt; findAll() {&#10;        log.debug(&quot;Obteniendo todos los diseños&quot;);&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findAll();&#10;&#10;        log.info(&quot;Se encontraron {} diseños&quot;, disenos.size());&#10;&#10;        return disenos.stream()&#10;                .map(this::mapToSimpleDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene un diseño completo por ID (con base64)&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public DisenoResponseDto findById(Integer id) {&#10;        log.debug(&quot;Obteniendo diseño con ID: {}&quot;, id);&#10;&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        log.debug(&quot;Diseño encontrado: {}&quot;, diseno.getNombre());&#10;        return mapToResponseDto(diseno);&#10;    }&#10;&#10;    /**&#10;     * Crea un nuevo diseño&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto save(DisenoCreateDto dto) {&#10;        log.info(&quot;Iniciando creación de diseño: {} para usuario: {}&quot;, dto.getNombre(), dto.getUsuarioId());&#10;&#10;        // 1. Validar que el usuario exista&#10;        Usuario usuario = usuarioRepository.findById(dto.getUsuarioId())&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Usuario no encontrado: {}&quot;, dto.getUsuarioId());&#10;                    return new EntityNotFoundException(&quot;Usuario&quot;, dto.getUsuarioId());&#10;                });&#10;&#10;        // 2. Validar que la plantilla exista&#10;        Plantilla plantilla = plantillaRepository.findById(dto.getPlantillaId())&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Plantilla no encontrada: {}&quot;, dto.getPlantillaId());&#10;                    return new EntityNotFoundException(&quot;Plantilla&quot;, dto.getPlantillaId());&#10;                });&#10;&#10;        // 3. Validar el base64 usando la utilidad&#10;        base64Validator.validateBase64ForPlantillaOrDiseno(dto.getBase64Diseno(), dto.getNombre());&#10;&#10;        // 4. Crear entidad&#10;        Diseno diseno = new Diseno();&#10;        diseno.setUsuario(usuario);&#10;        diseno.setPlantilla(plantilla);&#10;        diseno.setNombre(dto.getNombre());&#10;        diseno.setDescripcion(dto.getDescripcion());&#10;        diseno.setBase64Diseno(dto.getBase64Diseno());&#10;        diseno.setStatus(DisenoStatus.PROGRESO); // Estado inicial&#10;        diseno.setFechaCreacion(LocalDateTime.now());&#10;&#10;        // 5. Guardar&#10;        Diseno savedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño creado exitosamente con ID: {} para usuario: {}&quot;,&#10;                savedDiseno.getId(), dto.getUsuarioId());&#10;&#10;        return mapToResponseDto(savedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Actualiza un diseño existente&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto update(Integer id, DisenoUpdateDto dto) {&#10;        log.info(&quot;Iniciando actualización de diseño con ID: {}&quot;, id);&#10;&#10;        // 1. Buscar el diseño&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        // 2. Validar que no esté terminado (no se puede editar un diseño finalizado)&#10;        if (diseno.getStatus() == DisenoStatus.TERMINADO) {&#10;            log.error(&quot;No se puede actualizar un diseño en estado TERMINADO: {}&quot;, id);&#10;            throw new InvalidStateException(&quot;Diseño&quot;, &quot;TERMINADO&quot;, &quot;actualizar&quot;);&#10;        }&#10;&#10;        // 3. Actualizar datos básicos&#10;        diseno.setNombre(dto.getNombre());&#10;        diseno.setDescripcion(dto.getDescripcion());&#10;        diseno.setFechaActualizacion(LocalDateTime.now());&#10;&#10;        // 4. Si viene nueva imagen, actualizar usando la utilidad&#10;        if (dto.getBase64Diseno() != null &amp;&amp; !dto.getBase64Diseno().isEmpty()) {&#10;            base64Validator.validateBase64ForPlantillaOrDiseno(dto.getBase64Diseno(), dto.getNombre());&#10;            diseno.setBase64Diseno(dto.getBase64Diseno());&#10;            log.debug(&quot;Imagen del diseño actualizada&quot;);&#10;        }&#10;&#10;        // 5. Guardar&#10;        Diseno updatedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño actualizado exitosamente: {}&quot;, id);&#10;&#10;        return mapToResponseDto(updatedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Marca un diseño como terminado&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto marcarComoTerminado(Integer id) {&#10;        log.info(&quot;Marcando diseño {} como TERMINADO&quot;, id);&#10;&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        // Validar que esté en progreso&#10;        if (diseno.getStatus() == DisenoStatus.TERMINADO) {&#10;            log.warn(&quot;El diseño {} ya está en estado TERMINADO&quot;, id);&#10;            throw new InvalidStateException(&quot;Diseño&quot;, &quot;TERMINADO&quot;, &quot;marcar como terminado&quot;);&#10;        }&#10;&#10;        diseno.setStatus(DisenoStatus.TERMINADO);&#10;        diseno.setFechaActualizacion(LocalDateTime.now());&#10;&#10;        Diseno updatedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño {} marcado como TERMINADO exitosamente&quot;, id);&#10;&#10;        return mapToResponseDto(updatedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Marca un diseño como en progreso (reabrir)&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto marcarComoEnProgreso(Integer id) {&#10;        log.info(&quot;Marcando diseño {} como EN PROGRESO&quot;, id);&#10;&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        // Validar que esté terminado&#10;        if (diseno.getStatus() == DisenoStatus.PROGRESO) {&#10;            log.warn(&quot;El diseño {} ya está en estado PROGRESO&quot;, id);&#10;            throw new InvalidStateException(&quot;Diseño&quot;, &quot;PROGRESO&quot;, &quot;marcar como en progreso&quot;);&#10;        }&#10;&#10;        diseno.setStatus(DisenoStatus.PROGRESO);&#10;        diseno.setFechaActualizacion(LocalDateTime.now());&#10;&#10;        Diseno updatedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño {} marcado como EN PROGRESO exitosamente&quot;, id);&#10;&#10;        return mapToResponseDto(updatedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Elimina un diseño&#10;     */&#10;    @Transactional&#10;    public void deleteById(Integer id) {&#10;        log.info(&quot;Iniciando eliminación de diseño con ID: {}&quot;, id);&#10;&#10;        if (!disenoRepository.existsById(id)) {&#10;            log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;            throw new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;        }&#10;&#10;        disenoRepository.deleteById(id);&#10;&#10;        log.info(&quot;Diseño eliminado exitosamente: {}&quot;, id);&#10;    }&#10;&#10;    /**&#10;     * Elimina un diseño específico de un usuario&#10;     */&#10;    @Transactional&#10;    public void deleteByUsuario(UUID usuarioId, Integer disenoId) {&#10;        log.info(&quot;Eliminando diseño {} del usuario {}&quot;, disenoId, usuarioId);&#10;&#10;        Diseno diseno = disenoRepository.findById(disenoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, disenoId);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, disenoId);&#10;                });&#10;&#10;        // Validar que el diseño pertenece al usuario&#10;        if (!diseno.getUsuario().getId().equals(usuarioId)) {&#10;            log.error(&quot;El diseño {} no pertenece al usuario {}&quot;, disenoId, usuarioId);&#10;            throw new UnauthorizedAccessException(&#10;                    usuarioId.toString(),&#10;                    &quot;Diseño con ID &quot; + disenoId&#10;            );&#10;        }&#10;&#10;        disenoRepository.delete(diseno);&#10;&#10;        log.info(&quot;Diseño {} eliminado exitosamente del usuario {}&quot;, disenoId, usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Obtiene todos los diseños de un usuario (CON base64 para vista previa)&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public List&lt;DisenoResponseDto&gt; findByUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Obteniendo diseños del usuario: {}&quot;, usuarioId);&#10;&#10;        // Validar que el usuario exista&#10;        if (!usuarioRepository.existsById(usuarioId)) {&#10;            log.error(&quot;Usuario no encontrado: {}&quot;, usuarioId);&#10;            throw new EntityNotFoundException(&quot;Usuario&quot;, usuarioId);&#10;        }&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByUsuarioId(usuarioId);&#10;&#10;        log.info(&quot;Se encontraron {} diseños para el usuario: {}&quot;, disenos.size(), usuarioId);&#10;&#10;        // ✅ CAMBIO: Usar mapToResponseDto (con base64) en lugar de mapToSimpleDto&#10;        return disenos.stream()&#10;                .map(this::mapToResponseDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene diseños de un usuario por estado (CON base64 para vista previa)&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public List&lt;DisenoResponseDto&gt; findByUsuarioAndStatus(UUID usuarioId, DisenoStatus status) {&#10;        log.debug(&quot;Obteniendo diseños del usuario {} en estado {}&quot;, usuarioId, status);&#10;&#10;        // Validar que el usuario exista&#10;        if (!usuarioRepository.existsById(usuarioId)) {&#10;            log.error(&quot;Usuario no encontrado: {}&quot;, usuarioId);&#10;            throw new EntityNotFoundException(&quot;Usuario&quot;, usuarioId);&#10;        }&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByUsuarioIdAndStatus(usuarioId, status);&#10;&#10;        log.info(&quot;Se encontraron {} diseños en estado {} para el usuario: {}&quot;,&#10;                disenos.size(), status, usuarioId);&#10;&#10;        // ✅ CAMBIO: Usar mapToResponseDto (con base64) en lugar de mapToSimpleDto&#10;        return disenos.stream()&#10;                .map(this::mapToResponseDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene diseños de una plantilla específica&#10;     */&#10;    public List&lt;DisenoSimpleDto&gt; findByPlantilla(Integer plantillaId) {&#10;        log.debug(&quot;Obteniendo diseños de la plantilla: {}&quot;, plantillaId);&#10;&#10;        // Validar que la plantilla exista&#10;        if (!plantillaRepository.existsById(plantillaId)) {&#10;            log.error(&quot;Plantilla no encontrada: {}&quot;, plantillaId);&#10;            throw new EntityNotFoundException(&quot;Plantilla&quot;, plantillaId);&#10;        }&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByPlantillaId(plantillaId);&#10;&#10;        log.info(&quot;Se encontraron {} diseños para la plantilla: {}&quot;, disenos.size(), plantillaId);&#10;&#10;        return disenos.stream()&#10;                .map(this::mapToSimpleDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Busca diseños por nombre (búsqueda parcial)&#10;     */&#10;    public List&lt;DisenoSimpleDto&gt; searchByNombre(String nombre) {&#10;        log.debug(&quot;Buscando diseños que contengan: {}&quot;, nombre);&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByNombreContainingIgnoreCase(nombre);&#10;&#10;        log.info(&quot;Se encontraron {} diseños con el criterio: {}&quot;, disenos.size(), nombre);&#10;&#10;        return disenos.stream()&#10;                .map(this::mapToSimpleDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Cuenta diseños de un usuario&#10;     */&#10;    public long contarDisenosPorUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Contando diseños del usuario: {}&quot;, usuarioId);&#10;        return disenoRepository.countByUsuarioId(usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Cuenta diseños de un usuario por estado&#10;     */&#10;    public long contarDisenosPorUsuarioYEstado(UUID usuarioId, DisenoStatus status) {&#10;        log.debug(&quot;Contando diseños del usuario {} en estado {}&quot;, usuarioId, status);&#10;        return disenoRepository.countByUsuarioIdAndStatus(usuarioId, status);&#10;    }&#10;&#10;    // ==================== MÉTODOS PRIVADOS ====================&#10;&#10;    /**&#10;     * Mapea entidad a DTO de respuesta completo&#10;     */&#10;    private DisenoResponseDto mapToResponseDto(Diseno diseno) {&#10;        return DisenoResponseDto.builder()&#10;                .id(diseno.getId())&#10;                .nombre(diseno.getNombre())&#10;                .descripcion(diseno.getDescripcion())&#10;                .status(diseno.getStatus().name())&#10;                .base64Diseno(diseno.getBase64Diseno())&#10;                .plantillaId(diseno.getPlantilla().getId())&#10;                .plantillaNombre(diseno.getPlantilla().getNombre())&#10;                .fechaCreacion(diseno.getFechaCreacion())&#10;                .fechaActualizacion(diseno.getFechaActualizacion())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Mapea entidad a DTO simple (sin base64)&#10;     */&#10;    private DisenoSimpleDto mapToSimpleDto(Diseno diseno) {&#10;        return DisenoSimpleDto.builder()&#10;                .id(diseno.getId())&#10;                .nombre(diseno.getNombre())&#10;                .descripcion(diseno.getDescripcion())&#10;                .status(diseno.getStatus().name())&#10;                .plantillaNombre(diseno.getPlantilla().getNombre())&#10;                .fechaCreacion(diseno.getFechaCreacion())&#10;                .fechaActualizacion(diseno.getFechaActualizacion())&#10;                .build();&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.paper.service;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.paper.dtoCreate.DisenoCreateDto;&#10;import org.paper.dtoCreate.DisenoUpdateDto;&#10;import org.paper.dtoResponse.DisenoResponseDto;&#10;import org.paper.dtoResponse.DisenoSimpleDto;&#10;import org.paper.entity.Diseno;&#10;import org.paper.entity.DisenoStatus;&#10;import org.paper.entity.Plantilla;&#10;import org.paper.entity.Usuario;&#10;import org.paper.exception.EntityNotFoundException;&#10;import org.paper.exception.InvalidStateException;&#10;import org.paper.exception.UnauthorizedAccessException;&#10;import org.paper.repository.DisenoRepository;&#10;import org.paper.repository.PlantillaRepository;&#10;import org.paper.repository.UsuarioRepository;&#10;import org.paper.util.Base64ValidatorUtil;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;public class DisenoService {&#10;&#10;    private final DisenoRepository disenoRepository;&#10;    private final UsuarioRepository usuarioRepository;&#10;    private final PlantillaRepository plantillaRepository;&#10;    private final Base64ValidatorUtil base64Validator;&#10;&#10;    public DisenoService(DisenoRepository disenoRepository,&#10;                         UsuarioRepository usuarioRepository,&#10;                         PlantillaRepository plantillaRepository,&#10;                         Base64ValidatorUtil base64Validator) {&#10;        this.disenoRepository = disenoRepository;&#10;        this.usuarioRepository = usuarioRepository;&#10;        this.plantillaRepository = plantillaRepository;&#10;        this.base64Validator = base64Validator;&#10;    }&#10;&#10;    /**&#10;     * Obtiene todos los diseños (sin base64 para optimizar)&#10;     */&#10;    public List&lt;DisenoSimpleDto&gt; findAll() {&#10;        log.debug(&quot;Obteniendo todos los diseños&quot;);&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findAll();&#10;&#10;        log.info(&quot;Se encontraron {} diseños&quot;, disenos.size());&#10;&#10;        return disenos.stream()&#10;                .map(this::mapToSimpleDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene un diseño completo por ID (con base64)&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public DisenoResponseDto findById(Integer id) {&#10;        log.debug(&quot;Obteniendo diseño con ID: {}&quot;, id);&#10;&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        log.debug(&quot;Diseño encontrado: {}&quot;, diseno.getNombre());&#10;        return mapToResponseDto(diseno);&#10;    }&#10;&#10;    /**&#10;     * Crea un nuevo diseño&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto save(DisenoCreateDto dto) {&#10;        log.info(&quot;Iniciando creación de diseño: {} para usuario: {}&quot;, dto.getNombre(), dto.getUsuarioId());&#10;&#10;        // 1. Validar que el usuario exista&#10;        Usuario usuario = usuarioRepository.findById(dto.getUsuarioId())&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Usuario no encontrado: {}&quot;, dto.getUsuarioId());&#10;                    return new EntityNotFoundException(&quot;Usuario&quot;, dto.getUsuarioId());&#10;                });&#10;&#10;        // 2. Validar que la plantilla exista&#10;        Plantilla plantilla = plantillaRepository.findById(dto.getPlantillaId())&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Plantilla no encontrada: {}&quot;, dto.getPlantillaId());&#10;                    return new EntityNotFoundException(&quot;Plantilla&quot;, dto.getPlantillaId());&#10;                });&#10;&#10;        // 3. Validar el base64 usando la utilidad&#10;        base64Validator.validateBase64ForPlantillaOrDiseno(dto.getBase64Diseno(), dto.getNombre());&#10;&#10;        // 4. Crear entidad&#10;        Diseno diseno = new Diseno();&#10;        diseno.setUsuario(usuario);&#10;        diseno.setPlantilla(plantilla);&#10;        diseno.setNombre(dto.getNombre());&#10;        diseno.setDescripcion(dto.getDescripcion());&#10;        diseno.setBase64Diseno(dto.getBase64Diseno());&#10;        diseno.setStatus(DisenoStatus.PROGRESO); // Estado inicial&#10;        diseno.setFechaCreacion(LocalDateTime.now());&#10;&#10;        // 5. Guardar&#10;        Diseno savedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño creado exitosamente con ID: {} para usuario: {}&quot;,&#10;                savedDiseno.getId(), dto.getUsuarioId());&#10;&#10;        return mapToResponseDto(savedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Actualiza un diseño existente&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto update(Integer id, DisenoUpdateDto dto) {&#10;        log.info(&quot;Iniciando actualización de diseño con ID: {}&quot;, id);&#10;&#10;        // 1. Buscar el diseño&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        // 2. Validar que no esté terminado (no se puede editar un diseño finalizado)&#10;        if (diseno.getStatus() == DisenoStatus.TERMINADO) {&#10;            log.error(&quot;No se puede actualizar un diseño en estado TERMINADO: {}&quot;, id);&#10;            throw new InvalidStateException(&quot;Diseño&quot;, &quot;TERMINADO&quot;, &quot;actualizar&quot;);&#10;        }&#10;&#10;        // 3. Actualizar datos básicos&#10;        diseno.setNombre(dto.getNombre());&#10;        diseno.setDescripcion(dto.getDescripcion());&#10;        diseno.setFechaActualizacion(LocalDateTime.now());&#10;&#10;        // 4. Si viene nueva imagen, actualizar usando la utilidad&#10;        if (dto.getBase64Diseno() != null &amp;&amp; !dto.getBase64Diseno().isEmpty()) {&#10;            base64Validator.validateBase64ForPlantillaOrDiseno(dto.getBase64Diseno(), dto.getNombre());&#10;            diseno.setBase64Diseno(dto.getBase64Diseno());&#10;            log.debug(&quot;Imagen del diseño actualizada&quot;);&#10;        }&#10;&#10;        // 5. Guardar&#10;        Diseno updatedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño actualizado exitosamente: {}&quot;, id);&#10;&#10;        return mapToResponseDto(updatedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Marca un diseño como terminado&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto marcarComoTerminado(Integer id) {&#10;        log.info(&quot;Marcando diseño {} como TERMINADO&quot;, id);&#10;&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        // Validar que esté en progreso&#10;        if (diseno.getStatus() == DisenoStatus.TERMINADO) {&#10;            log.warn(&quot;El diseño {} ya está en estado TERMINADO&quot;, id);&#10;            throw new InvalidStateException(&quot;Diseño&quot;, &quot;TERMINADO&quot;, &quot;marcar como terminado&quot;);&#10;        }&#10;&#10;        diseno.setStatus(DisenoStatus.TERMINADO);&#10;        diseno.setFechaActualizacion(LocalDateTime.now());&#10;&#10;        Diseno updatedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño {} marcado como TERMINADO exitosamente&quot;, id);&#10;&#10;        return mapToResponseDto(updatedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Marca un diseño como en progreso (reabrir)&#10;     */&#10;    @Transactional&#10;    public DisenoResponseDto marcarComoEnProgreso(Integer id) {&#10;        log.info(&quot;Marcando diseño {} como EN PROGRESO&quot;, id);&#10;&#10;        Diseno diseno = disenoRepository.findById(id)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;                });&#10;&#10;        // Validar que esté terminado&#10;        if (diseno.getStatus() == DisenoStatus.PROGRESO) {&#10;            log.warn(&quot;El diseño {} ya está en estado PROGRESO&quot;, id);&#10;            throw new InvalidStateException(&quot;Diseño&quot;, &quot;PROGRESO&quot;, &quot;marcar como en progreso&quot;);&#10;        }&#10;&#10;        diseno.setStatus(DisenoStatus.PROGRESO);&#10;        diseno.setFechaActualizacion(LocalDateTime.now());&#10;&#10;        Diseno updatedDiseno = disenoRepository.save(diseno);&#10;&#10;        log.info(&quot;Diseño {} marcado como EN PROGRESO exitosamente&quot;, id);&#10;&#10;        return mapToResponseDto(updatedDiseno);&#10;    }&#10;&#10;    /**&#10;     * Elimina un diseño&#10;     */&#10;    @Transactional&#10;    public void deleteById(Integer id) {&#10;        log.info(&quot;Iniciando eliminación de diseño con ID: {}&quot;, id);&#10;&#10;        if (!disenoRepository.existsById(id)) {&#10;            log.error(&quot;Diseño no encontrado: {}&quot;, id);&#10;            throw new EntityNotFoundException(&quot;Diseño&quot;, id);&#10;        }&#10;&#10;        disenoRepository.deleteById(id);&#10;&#10;        log.info(&quot;Diseño eliminado exitosamente: {}&quot;, id);&#10;    }&#10;&#10;    /**&#10;     * Elimina un diseño específico de un usuario&#10;     */&#10;    @Transactional&#10;    public void deleteByUsuario(UUID usuarioId, Integer disenoId) {&#10;        log.info(&quot;Eliminando diseño {} del usuario {}&quot;, disenoId, usuarioId);&#10;&#10;        Diseno diseno = disenoRepository.findById(disenoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Diseño no encontrado: {}&quot;, disenoId);&#10;                    return new EntityNotFoundException(&quot;Diseño&quot;, disenoId);&#10;                });&#10;&#10;        // Validar que el diseño pertenece al usuario&#10;        if (!diseno.getUsuario().getId().equals(usuarioId)) {&#10;            log.error(&quot;El diseño {} no pertenece al usuario {}&quot;, disenoId, usuarioId);&#10;            throw new UnauthorizedAccessException(&#10;                    usuarioId.toString(),&#10;                    &quot;Diseño con ID &quot; + disenoId&#10;            );&#10;        }&#10;&#10;        disenoRepository.delete(diseno);&#10;&#10;        log.info(&quot;Diseño {} eliminado exitosamente del usuario {}&quot;, disenoId, usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Obtiene todos los diseños de un usuario (CON base64 para vista previa)&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public List&lt;DisenoResponseDto&gt; findByUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Obteniendo diseños del usuario: {}&quot;, usuarioId);&#10;&#10;        // Validar que el usuario exista&#10;        if (!usuarioRepository.existsById(usuarioId)) {&#10;            log.error(&quot;Usuario no encontrado: {}&quot;, usuarioId);&#10;            throw new EntityNotFoundException(&quot;Usuario&quot;, usuarioId);&#10;        }&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByUsuarioId(usuarioId);&#10;&#10;        log.info(&quot;Se encontraron {} diseños para el usuario: {}&quot;, disenos.size(), usuarioId);&#10;&#10;        // ✅ CAMBIO: Usar mapToResponseDto (con base64) en lugar de mapToSimpleDto&#10;        return disenos.stream()&#10;                .map(this::mapToResponseDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene diseños de un usuario por estado (CON base64 para vista previa)&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public List&lt;DisenoResponseDto&gt; findByUsuarioAndStatus(UUID usuarioId, DisenoStatus status) {&#10;        log.debug(&quot;Obteniendo diseños del usuario {} en estado {}&quot;, usuarioId, status);&#10;&#10;        // Validar que el usuario exista&#10;        if (!usuarioRepository.existsById(usuarioId)) {&#10;            log.error(&quot;Usuario no encontrado: {}&quot;, usuarioId);&#10;            throw new EntityNotFoundException(&quot;Usuario&quot;, usuarioId);&#10;        }&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByUsuarioIdAndStatus(usuarioId, status);&#10;&#10;        log.info(&quot;Se encontraron {} diseños en estado {} para el usuario: {}&quot;,&#10;                disenos.size(), status, usuarioId);&#10;&#10;        // ✅ CAMBIO: Usar mapToResponseDto (con base64) en lugar de mapToSimpleDto&#10;        return disenos.stream()&#10;                .map(this::mapToResponseDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene diseños de una plantilla específica&#10;     */&#10;    public List&lt;DisenoSimpleDto&gt; findByPlantilla(Integer plantillaId) {&#10;        log.debug(&quot;Obteniendo diseños de la plantilla: {}&quot;, plantillaId);&#10;&#10;        // Validar que la plantilla exista&#10;        if (!plantillaRepository.existsById(plantillaId)) {&#10;            log.error(&quot;Plantilla no encontrada: {}&quot;, plantillaId);&#10;            throw new EntityNotFoundException(&quot;Plantilla&quot;, plantillaId);&#10;        }&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByPlantillaId(plantillaId);&#10;&#10;        log.info(&quot;Se encontraron {} diseños para la plantilla: {}&quot;, disenos.size(), plantillaId);&#10;&#10;        return disenos.stream()&#10;                .map(this::mapToSimpleDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Busca diseños por nombre (búsqueda parcial)&#10;     */&#10;    public List&lt;DisenoSimpleDto&gt; searchByNombre(String nombre) {&#10;        log.debug(&quot;Buscando diseños que contengan: {}&quot;, nombre);&#10;&#10;        List&lt;Diseno&gt; disenos = disenoRepository.findByNombreContainingIgnoreCase(nombre);&#10;&#10;        log.info(&quot;Se encontraron {} diseños con el criterio: {}&quot;, disenos.size(), nombre);&#10;&#10;        return disenos.stream()&#10;                .map(this::mapToSimpleDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Cuenta diseños de un usuario&#10;     */&#10;    public long contarDisenosPorUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Contando diseños del usuario: {}&quot;, usuarioId);&#10;        return disenoRepository.countByUsuarioId(usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Cuenta diseños de un usuario por estado&#10;     */&#10;    public long contarDisenosPorUsuarioYEstado(UUID usuarioId, DisenoStatus status) {&#10;        log.debug(&quot;Contando diseños del usuario {} en estado {}&quot;, usuarioId, status);&#10;        return disenoRepository.countByUsuarioIdAndStatus(usuarioId, status);&#10;    }&#10;&#10;    // ==================== MÉTODOS PRIVADOS ====================&#10;&#10;    /**&#10;     * Mapea entidad a DTO de respuesta completo&#10;     */&#10;    private DisenoResponseDto mapToResponseDto(Diseno diseno) {&#10;        return DisenoResponseDto.builder()&#10;                .id(diseno.getId())&#10;                .nombre(diseno.getNombre())&#10;                .descripcion(diseno.getDescripcion())&#10;                .status(diseno.getStatus().name())&#10;                .base64Diseno(diseno.getBase64Diseno())&#10;                .plantillaId(diseno.getPlantilla().getId())&#10;                .plantillaNombre(diseno.getPlantilla().getNombre())&#10;                .fechaCreacion(diseno.getFechaCreacion())&#10;                .fechaActualizacion(diseno.getFechaActualizacion())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Mapea entidad a DTO simple (sin base64)&#10;     */&#10;    private DisenoSimpleDto mapToSimpleDto(Diseno diseno) {&#10;        return DisenoSimpleDto.builder()&#10;                .id(diseno.getId())&#10;                .nombre(diseno.getNombre())&#10;                .descripcion(diseno.getDescripcion())&#10;                .status(diseno.getStatus().name())&#10;                .plantillaNombre(diseno.getPlantilla().getNombre())&#10;                .fechaCreacion(diseno.getFechaCreacion())&#10;                .fechaActualizacion(diseno.getFechaActualizacion())&#10;                .build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/paper/service/LogoService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/paper/service/LogoService.java" />
              <option name="originalContent" value="package org.paper.service;&#10;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.paper.dtoCreate.LogoCreateDto;&#10;import org.paper.dtoCreate.LogoUpdateDto;&#10;import org.paper.dtoResponse.LogoResponseDto;&#10;import org.paper.entity.Logo;&#10;import org.paper.entity.Usuario;&#10;import org.paper.exception.EntityNotFoundException;&#10;import org.paper.exception.UnauthorizedAccessException;&#10;import org.paper.repository.LogoRepository;&#10;import org.paper.repository.UsuarioRepository;&#10;import org.paper.util.Base64ValidatorUtil;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;public class LogoService {&#10;&#10;    private final LogoRepository logoRepository;&#10;    private final UsuarioRepository usuarioRepository;&#10;    private final Base64ValidatorUtil base64Validator;&#10;&#10;    public LogoService(LogoRepository logoRepository,&#10;                       UsuarioRepository usuarioRepository,&#10;                       Base64ValidatorUtil base64Validator) {&#10;        this.logoRepository = logoRepository;&#10;        this.usuarioRepository = usuarioRepository;&#10;        this.base64Validator = base64Validator;&#10;    }&#10;&#10;    /**&#10;     * Crea un nuevo logo para un usuario&#10;     */&#10;    @Transactional&#10;    public LogoResponseDto crearLogo(LogoCreateDto dto) {&#10;        log.info(&quot;Iniciando creación de logo '{}' para usuario: {}&quot;, dto.getNombre(), dto.getUsuarioId());&#10;&#10;        // 1. Validar que el usuario exista&#10;        Usuario usuario = usuarioRepository.findById(dto.getUsuarioId())&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Usuario no encontrado: {}&quot;, dto.getUsuarioId());&#10;                    return new EntityNotFoundException(&quot;Usuario&quot;, dto.getUsuarioId());&#10;                });&#10;&#10;        // 2. Validar el base64 usando la utilidad&#10;        base64Validator.validateBase64ForLogo(dto.getBase64Logo(), dto.getNombre());&#10;&#10;        // 3. Calcular tamaño usando la utilidad&#10;        long tamanoBytes = base64Validator.calculateBase64Size(dto.getBase64Logo());&#10;&#10;        // 4. Crear entidad&#10;        Logo logo = new Logo();&#10;        logo.setUsuario(usuario);&#10;        logo.setNombre(dto.getNombre());&#10;        logo.setBase64Logo(dto.getBase64Logo());&#10;        logo.setFechaCreacion(LocalDateTime.now());&#10;        logo.setTamanoBytes(tamanoBytes);&#10;&#10;        // 5. Guardar&#10;        Logo savedLogo = logoRepository.save(logo);&#10;&#10;        log.info(&quot;Logo creado exitosamente con ID: {} para usuario: {}&quot;,&#10;                savedLogo.getId(), dto.getUsuarioId());&#10;&#10;        return mapToResponseDto(savedLogo);&#10;    }&#10;&#10;    /**&#10;     * Obtiene todos los logos de un usuario&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public List&lt;LogoResponseDto&gt; obtenerLogosPorUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Obteniendo logos para usuario: {}&quot;, usuarioId);&#10;&#10;        // Validar que el usuario exista&#10;        if (!usuarioRepository.existsById(usuarioId)) {&#10;            log.error(&quot;Usuario no encontrado: {}&quot;, usuarioId);&#10;            throw new EntityNotFoundException(&quot;Usuario&quot;, usuarioId);&#10;        }&#10;&#10;        List&lt;Logo&gt; logos = logoRepository.findByUsuarioId(usuarioId);&#10;&#10;        log.info(&quot;Se encontraron {} logos para el usuario: {}&quot;, logos.size(), usuarioId);&#10;&#10;        return logos.stream()&#10;                .map(this::mapToResponseDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene un logo específico por ID&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public LogoResponseDto obtenerLogoPorId(Integer logoId) {&#10;        log.debug(&quot;Obteniendo logo con ID: {}&quot;, logoId);&#10;&#10;        Logo logo = logoRepository.findById(logoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;                    return new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;                });&#10;&#10;        log.debug(&quot;Logo encontrado: {}&quot;, logoId);&#10;        return mapToResponseDto(logo);&#10;    }&#10;&#10;    /**&#10;     * Actualiza un logo existente&#10;     */&#10;    @Transactional&#10;    public LogoResponseDto actualizarLogo(Integer logoId, LogoUpdateDto dto) {&#10;        log.info(&quot;Iniciando actualización de logo con ID: {}&quot;, logoId);&#10;&#10;        // 1. Buscar el logo&#10;        Logo logo = logoRepository.findById(logoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;                    return new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;                });&#10;&#10;        // 2. Actualizar nombre&#10;        logo.setNombre(dto.getNombre());&#10;&#10;        // 3. Si viene nueva imagen, actualizar usando la utilidad&#10;        if (dto.getBase64Logo() != null &amp;&amp; !dto.getBase64Logo().isEmpty()) {&#10;            base64Validator.validateBase64ForLogo(dto.getBase64Logo(), dto.getNombre());&#10;            logo.setBase64Logo(dto.getBase64Logo());&#10;            logo.setTamanoBytes(base64Validator.calculateBase64Size(dto.getBase64Logo()));&#10;            log.debug(&quot;Imagen del logo actualizada&quot;);&#10;        }&#10;&#10;        // 4. Guardar&#10;        Logo updatedLogo = logoRepository.save(logo);&#10;&#10;        log.info(&quot;Logo actualizado exitosamente: {}&quot;, logoId);&#10;&#10;        return mapToResponseDto(updatedLogo);&#10;    }&#10;&#10;    /**&#10;     * Elimina un logo&#10;     */&#10;    @Transactional&#10;    public void eliminarLogo(Integer logoId) {&#10;        log.info(&quot;Iniciando eliminación de logo con ID: {}&quot;, logoId);&#10;&#10;        // Verificar que existe&#10;        if (!logoRepository.existsById(logoId)) {&#10;            log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;            throw new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;        }&#10;&#10;        logoRepository.deleteById(logoId);&#10;&#10;        log.info(&quot;Logo eliminado exitosamente: {}&quot;, logoId);&#10;    }&#10;&#10;    /**&#10;     * Elimina un logo específico de un usuario&#10;     */&#10;    @Transactional&#10;    public void eliminarLogoPorUsuario(UUID usuarioId, Integer logoId) {&#10;        log.info(&quot;Eliminando logo {} del usuario {}&quot;, logoId, usuarioId);&#10;&#10;        Logo logo = logoRepository.findById(logoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;                    return new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;                });&#10;&#10;        // Validar que el logo pertenece al usuario&#10;        if (!logo.getUsuario().getId().equals(usuarioId)) {&#10;            log.error(&quot;El logo {} no pertenece al usuario {}&quot;, logoId, usuarioId);&#10;            throw new UnauthorizedAccessException(&#10;                    usuarioId.toString(),&#10;                    &quot;Logo con ID &quot; + logoId&#10;            );&#10;        }&#10;&#10;        logoRepository.delete(logo);&#10;&#10;        log.info(&quot;Logo {} eliminado exitosamente del usuario {}&quot;, logoId, usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Obtiene la cantidad de logos de un usuario&#10;     */&#10;    public long contarLogosPorUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Contando logos del usuario: {}&quot;, usuarioId);&#10;        return logoRepository.countByUsuarioId(usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Mapea entidad a DTO de respuesta&#10;     */&#10;    private LogoResponseDto mapToResponseDto(Logo logo) {&#10;        return LogoResponseDto.builder()&#10;                .id(logo.getId())&#10;                .nombre(logo.getNombre())&#10;                .base64Logo(logo.getBase64Logo())&#10;                .build();&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.paper.service;&#10;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.paper.dtoCreate.LogoCreateDto;&#10;import org.paper.dtoCreate.LogoUpdateDto;&#10;import org.paper.dtoResponse.LogoResponseDto;&#10;import org.paper.entity.Logo;&#10;import org.paper.entity.Usuario;&#10;import org.paper.exception.EntityNotFoundException;&#10;import org.paper.exception.UnauthorizedAccessException;&#10;import org.paper.repository.LogoRepository;&#10;import org.paper.repository.UsuarioRepository;&#10;import org.paper.util.Base64ValidatorUtil;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;public class LogoService {&#10;&#10;    private final LogoRepository logoRepository;&#10;    private final UsuarioRepository usuarioRepository;&#10;    private final Base64ValidatorUtil base64Validator;&#10;&#10;    public LogoService(LogoRepository logoRepository,&#10;                       UsuarioRepository usuarioRepository,&#10;                       Base64ValidatorUtil base64Validator) {&#10;        this.logoRepository = logoRepository;&#10;        this.usuarioRepository = usuarioRepository;&#10;        this.base64Validator = base64Validator;&#10;    }&#10;&#10;    /**&#10;     * Crea un nuevo logo para un usuario&#10;     */&#10;    @Transactional&#10;    public LogoResponseDto crearLogo(LogoCreateDto dto) {&#10;        log.info(&quot;Iniciando creación de logo '{}' para usuario: {}&quot;, dto.getNombre(), dto.getUsuarioId());&#10;&#10;        // 1. Validar que el usuario exista&#10;        Usuario usuario = usuarioRepository.findById(dto.getUsuarioId())&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Usuario no encontrado: {}&quot;, dto.getUsuarioId());&#10;                    return new EntityNotFoundException(&quot;Usuario&quot;, dto.getUsuarioId());&#10;                });&#10;&#10;        // 2. Validar el base64 usando la utilidad&#10;        base64Validator.validateBase64ForLogo(dto.getBase64Logo(), dto.getNombre());&#10;&#10;        // 3. Calcular tamaño usando la utilidad&#10;        long tamanoBytes = base64Validator.calculateBase64Size(dto.getBase64Logo());&#10;&#10;        // 4. Crear entidad&#10;        Logo logo = new Logo();&#10;        logo.setUsuario(usuario);&#10;        logo.setNombre(dto.getNombre());&#10;        logo.setBase64Logo(dto.getBase64Logo());&#10;        logo.setFechaCreacion(LocalDateTime.now());&#10;        logo.setTamanoBytes(tamanoBytes);&#10;&#10;        // 5. Guardar&#10;        Logo savedLogo = logoRepository.save(logo);&#10;&#10;        log.info(&quot;Logo creado exitosamente con ID: {} para usuario: {}&quot;,&#10;                savedLogo.getId(), dto.getUsuarioId());&#10;&#10;        return mapToResponseDto(savedLogo);&#10;    }&#10;&#10;    /**&#10;     * Obtiene todos los logos de un usuario&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public List&lt;LogoResponseDto&gt; obtenerLogosPorUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Obteniendo logos para usuario: {}&quot;, usuarioId);&#10;&#10;        // Validar que el usuario exista&#10;        if (!usuarioRepository.existsById(usuarioId)) {&#10;            log.error(&quot;Usuario no encontrado: {}&quot;, usuarioId);&#10;            throw new EntityNotFoundException(&quot;Usuario&quot;, usuarioId);&#10;        }&#10;&#10;        List&lt;Logo&gt; logos = logoRepository.findByUsuarioId(usuarioId);&#10;&#10;        log.info(&quot;Se encontraron {} logos para el usuario: {}&quot;, logos.size(), usuarioId);&#10;&#10;        return logos.stream()&#10;                .map(this::mapToResponseDto)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtiene un logo específico por ID&#10;     */&#10;    @Transactional(readOnly = true)&#10;    public LogoResponseDto obtenerLogoPorId(Integer logoId) {&#10;        log.debug(&quot;Obteniendo logo con ID: {}&quot;, logoId);&#10;&#10;        Logo logo = logoRepository.findById(logoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;                    return new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;                });&#10;&#10;        log.debug(&quot;Logo encontrado: {}&quot;, logoId);&#10;        return mapToResponseDto(logo);&#10;    }&#10;&#10;    /**&#10;     * Actualiza un logo existente&#10;     */&#10;    @Transactional&#10;    public LogoResponseDto actualizarLogo(Integer logoId, LogoUpdateDto dto) {&#10;        log.info(&quot;Iniciando actualización de logo con ID: {}&quot;, logoId);&#10;&#10;        // 1. Buscar el logo&#10;        Logo logo = logoRepository.findById(logoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;                    return new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;                });&#10;&#10;        // 2. Actualizar nombre&#10;        logo.setNombre(dto.getNombre());&#10;&#10;        // 3. Si viene nueva imagen, actualizar usando la utilidad&#10;        if (dto.getBase64Logo() != null &amp;&amp; !dto.getBase64Logo().isEmpty()) {&#10;            base64Validator.validateBase64ForLogo(dto.getBase64Logo(), dto.getNombre());&#10;            logo.setBase64Logo(dto.getBase64Logo());&#10;            logo.setTamanoBytes(base64Validator.calculateBase64Size(dto.getBase64Logo()));&#10;            log.debug(&quot;Imagen del logo actualizada&quot;);&#10;        }&#10;&#10;        // 4. Guardar&#10;        Logo updatedLogo = logoRepository.save(logo);&#10;&#10;        log.info(&quot;Logo actualizado exitosamente: {}&quot;, logoId);&#10;&#10;        return mapToResponseDto(updatedLogo);&#10;    }&#10;&#10;    /**&#10;     * Elimina un logo&#10;     */&#10;    @Transactional&#10;    public void eliminarLogo(Integer logoId) {&#10;        log.info(&quot;Iniciando eliminación de logo con ID: {}&quot;, logoId);&#10;&#10;        // Verificar que existe&#10;        if (!logoRepository.existsById(logoId)) {&#10;            log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;            throw new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;        }&#10;&#10;        logoRepository.deleteById(logoId);&#10;&#10;        log.info(&quot;Logo eliminado exitosamente: {}&quot;, logoId);&#10;    }&#10;&#10;    /**&#10;     * Elimina un logo específico de un usuario&#10;     */&#10;    @Transactional&#10;    public void eliminarLogoPorUsuario(UUID usuarioId, Integer logoId) {&#10;        log.info(&quot;Eliminando logo {} del usuario {}&quot;, logoId, usuarioId);&#10;&#10;        Logo logo = logoRepository.findById(logoId)&#10;                .orElseThrow(() -&gt; {&#10;                    log.error(&quot;Logo no encontrado: {}&quot;, logoId);&#10;                    return new EntityNotFoundException(&quot;Logo&quot;, logoId);&#10;                });&#10;&#10;        // Validar que el logo pertenece al usuario&#10;        if (!logo.getUsuario().getId().equals(usuarioId)) {&#10;            log.error(&quot;El logo {} no pertenece al usuario {}&quot;, logoId, usuarioId);&#10;            throw new UnauthorizedAccessException(&#10;                    usuarioId.toString(),&#10;                    &quot;Logo con ID &quot; + logoId&#10;            );&#10;        }&#10;&#10;        logoRepository.delete(logo);&#10;&#10;        log.info(&quot;Logo {} eliminado exitosamente del usuario {}&quot;, logoId, usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Obtiene la cantidad de logos de un usuario&#10;     */&#10;    public long contarLogosPorUsuario(UUID usuarioId) {&#10;        log.debug(&quot;Contando logos del usuario: {}&quot;, usuarioId);&#10;        return logoRepository.countByUsuarioId(usuarioId);&#10;    }&#10;&#10;    /**&#10;     * Mapea entidad a DTO de respuesta&#10;     */&#10;    private LogoResponseDto mapToResponseDto(Logo logo) {&#10;        return LogoResponseDto.builder()&#10;                .id(logo.getId())&#10;                .nombre(logo.getNombre())&#10;                .base64Logo(logo.getBase64Logo())&#10;                .build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/DisenoControllerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/DisenoControllerTest.java" />
              <option name="originalContent" value="import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.paper.controller.DisenoController;&#10;import org.paper.dtoCreate.DisenoCreateDto;&#10;import org.paper.dtoCreate.DisenoUpdateDto;&#10;import org.paper.dtoResponse.DisenoResponseDto;&#10;import org.paper.entity.DisenoStatus;&#10;import org.paper.service.DisenoService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;&#10;import org.springframework.boot.test.mock.mockito.MockBean;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.test.context.ContextConfiguration;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.Arrays;&#10;import java.util.UUID;&#10;import java.util.Collections;&#10;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.eq;&#10;import static org.mockito.Mockito.*;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@WebMvcTest(DisenoController.class)&#10;@ContextConfiguration(classes = org.paper.Main.class)&#10;class DisenoControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    @MockBean&#10;    private DisenoService disenoService;&#10;&#10;    private UUID usuarioId;&#10;    private DisenoResponseDto disenoResponseDto;&#10;    private DisenoCreateDto disenoCreateDto;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        usuarioId = UUID.randomUUID();&#10;&#10;        disenoResponseDto = DisenoResponseDto.builder()&#10;                .id(1)&#10;                .nombre(&quot;Diseño Test&quot;)&#10;                .descripcion(&quot;Descripción Test&quot;)&#10;                .status(&quot;PROGRESO&quot;)&#10;                .base64Diseno(&quot;base64string&quot;)&#10;                .plantillaId(1)&#10;                .plantillaNombre(&quot;Plantilla Test&quot;)&#10;                .fechaCreacion(LocalDateTime.now())&#10;                .build();&#10;&#10;        disenoCreateDto = new DisenoCreateDto();&#10;        disenoCreateDto.setUsuarioId(usuarioId);&#10;        disenoCreateDto.setPlantillaId(1);&#10;        disenoCreateDto.setNombre(&quot;Nuevo Diseño&quot;);&#10;        disenoCreateDto.setDescripcion(&quot;Nueva Descripción&quot;);&#10;        disenoCreateDto.setBase64Diseno(&quot;base64string&quot;);&#10;    }&#10;&#10;    @Test&#10;    void crearDiseno_DeberiaRetornar201() throws Exception {&#10;        // Arrange&#10;        when(disenoService.save(any(DisenoCreateDto.class))).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(post(&quot;/api/disenos&quot;)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(disenoCreateDto)))&#10;                .andExpect(status().isCreated())&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Diseño Test&quot;));&#10;&#10;        verify(disenoService).save(any(DisenoCreateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void obtenerDisenoPorId_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.findById(1)).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/{id}&quot;, 1))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Diseño Test&quot;))&#10;                .andExpect(jsonPath(&quot;$.data.status&quot;).value(&quot;PROGRESO&quot;));&#10;&#10;        verify(disenoService).findById(1);&#10;    }&#10;&#10;    @Test&#10;    void actualizarDiseno_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        DisenoUpdateDto updateDto = new DisenoUpdateDto();&#10;        updateDto.setNombre(&quot;Diseño Actualizado&quot;);&#10;        updateDto.setDescripcion(&quot;Descripción Actualizada&quot;);&#10;&#10;        when(disenoService.update(eq(1), any(DisenoUpdateDto.class)))&#10;                .thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(put(&quot;/api/disenos/{id}&quot;, 1)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(updateDto)))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).update(eq(1), any(DisenoUpdateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void marcarComoTerminado_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.marcarComoTerminado(1)).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(patch(&quot;/api/disenos/{id}/terminar&quot;, 1))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).marcarComoTerminado(1);&#10;    }&#10;&#10;    @Test&#10;    void marcarComoEnProgreso_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.marcarComoEnProgreso(1)).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(patch(&quot;/api/disenos/{id}/reabrir&quot;, 1))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).marcarComoEnProgreso(1);&#10;    }&#10;&#10;    @Test&#10;    void eliminarDiseno_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        doNothing().when(disenoService).deleteById(1);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(delete(&quot;/api/disenos/{id}&quot;, 1))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).deleteById(1);&#10;    }&#10;&#10;    @Test&#10;    void obtenerDisenosPorUsuario_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.findByUsuario(usuarioId))&#10;                .thenReturn(Collections.singletonList(disenoResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}&quot;, usuarioId))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data[0].nombre&quot;).value(&quot;Diseño Test&quot;));&#10;&#10;        verify(disenoService).findByUsuario(usuarioId);&#10;    }&#10;&#10;    @Test&#10;    void obtenerDisenosPorUsuarioYEstado_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.findByUsuarioAndStatus(usuarioId, DisenoStatus.PROGRESO))&#10;                .thenReturn(Collections.singletonList(disenoResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}/status/{status}&quot;,&#10;                        usuarioId, &quot;PROGRESO&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data[0].status&quot;).value(&quot;PROGRESO&quot;));&#10;&#10;        verify(disenoService).findByUsuarioAndStatus(usuarioId, DisenoStatus.PROGRESO);&#10;    }&#10;&#10;    @Test&#10;    void contarDisenosPorUsuario_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.contarDisenosPorUsuario(usuarioId)).thenReturn(3L);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}/count&quot;, usuarioId))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).value(3));&#10;&#10;        verify(disenoService).contarDisenosPorUsuario(usuarioId);&#10;    }&#10;&#10;    @Test&#10;    void contarDisenosPorUsuarioYEstado_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.contarDisenosPorUsuarioYEstado(usuarioId, DisenoStatus.PROGRESO))&#10;                .thenReturn(2L);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}/count/{status}&quot;,&#10;                        usuarioId, &quot;PROGRESO&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).value(2));&#10;&#10;        verify(disenoService).contarDisenosPorUsuarioYEstado(usuarioId, DisenoStatus.PROGRESO);&#10;    }&#10;}" />
              <option name="updatedContent" value="import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.paper.controller.DisenoController;&#10;import org.paper.dtoCreate.DisenoCreateDto;&#10;import org.paper.dtoCreate.DisenoUpdateDto;&#10;import org.paper.dtoResponse.DisenoResponseDto;&#10;import org.paper.entity.DisenoStatus;&#10;import org.paper.service.DisenoService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;&#10;import org.springframework.boot.test.mock.mockito.MockBean;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.test.context.ContextConfiguration;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;import java.util.Collections;&#10;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.eq;&#10;import static org.mockito.Mockito.*;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@WebMvcTest(DisenoController.class)&#10;@ContextConfiguration(classes = org.paper.Main.class)&#10;class DisenoControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    @MockBean&#10;    private DisenoService disenoService;&#10;&#10;    private UUID usuarioId;&#10;    private DisenoResponseDto disenoResponseDto;&#10;    private DisenoCreateDto disenoCreateDto;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        usuarioId = UUID.randomUUID();&#10;&#10;        disenoResponseDto = DisenoResponseDto.builder()&#10;                .id(1)&#10;                .nombre(&quot;Diseño Test&quot;)&#10;                .descripcion(&quot;Descripción Test&quot;)&#10;                .status(&quot;PROGRESO&quot;)&#10;                .base64Diseno(&quot;base64string&quot;)&#10;                .plantillaId(1)&#10;                .plantillaNombre(&quot;Plantilla Test&quot;)&#10;                .fechaCreacion(LocalDateTime.now())&#10;                .build();&#10;&#10;        disenoCreateDto = new DisenoCreateDto();&#10;        disenoCreateDto.setUsuarioId(usuarioId);&#10;        disenoCreateDto.setPlantillaId(1);&#10;        disenoCreateDto.setNombre(&quot;Nuevo Diseño&quot;);&#10;        disenoCreateDto.setDescripcion(&quot;Nueva Descripción&quot;);&#10;        disenoCreateDto.setBase64Diseno(&quot;base64string&quot;);&#10;    }&#10;&#10;    @Test&#10;    void crearDiseno_DeberiaRetornar201() throws Exception {&#10;        // Arrange&#10;        when(disenoService.save(any(DisenoCreateDto.class))).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(post(&quot;/api/disenos&quot;)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(disenoCreateDto)))&#10;                .andExpect(status().isCreated())&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Diseño Test&quot;));&#10;&#10;        verify(disenoService).save(any(DisenoCreateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void obtenerDisenoPorId_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.findById(1)).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/{id}&quot;, 1))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Diseño Test&quot;))&#10;                .andExpect(jsonPath(&quot;$.data.status&quot;).value(&quot;PROGRESO&quot;));&#10;&#10;        verify(disenoService).findById(1);&#10;    }&#10;&#10;    @Test&#10;    void actualizarDiseno_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        DisenoUpdateDto updateDto = new DisenoUpdateDto();&#10;        updateDto.setNombre(&quot;Diseño Actualizado&quot;);&#10;        updateDto.setDescripcion(&quot;Descripción Actualizada&quot;);&#10;&#10;        when(disenoService.update(eq(1), any(DisenoUpdateDto.class)))&#10;                .thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(put(&quot;/api/disenos/{id}&quot;, 1)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(updateDto)))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).update(eq(1), any(DisenoUpdateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void marcarComoTerminado_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.marcarComoTerminado(1)).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(patch(&quot;/api/disenos/{id}/terminar&quot;, 1))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).marcarComoTerminado(1);&#10;    }&#10;&#10;    @Test&#10;    void marcarComoEnProgreso_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.marcarComoEnProgreso(1)).thenReturn(disenoResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(patch(&quot;/api/disenos/{id}/reabrir&quot;, 1))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).marcarComoEnProgreso(1);&#10;    }&#10;&#10;    @Test&#10;    void eliminarDiseno_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        doNothing().when(disenoService).deleteById(1);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(delete(&quot;/api/disenos/{id}&quot;, 1))&#10;                .andExpect(status().isOk());&#10;&#10;        verify(disenoService).deleteById(1);&#10;    }&#10;&#10;    @Test&#10;    void obtenerDisenosPorUsuario_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.findByUsuario(usuarioId))&#10;                .thenReturn(Collections.singletonList(disenoResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}&quot;, usuarioId))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data[0].nombre&quot;).value(&quot;Diseño Test&quot;));&#10;&#10;        verify(disenoService).findByUsuario(usuarioId);&#10;    }&#10;&#10;    @Test&#10;    void obtenerDisenosPorUsuarioYEstado_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.findByUsuarioAndStatus(usuarioId, DisenoStatus.PROGRESO))&#10;                .thenReturn(Collections.singletonList(disenoResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}/status/{status}&quot;,&#10;                        usuarioId, &quot;PROGRESO&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data[0].status&quot;).value(&quot;PROGRESO&quot;));&#10;&#10;        verify(disenoService).findByUsuarioAndStatus(usuarioId, DisenoStatus.PROGRESO);&#10;    }&#10;&#10;    @Test&#10;    void contarDisenosPorUsuario_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.contarDisenosPorUsuario(usuarioId)).thenReturn(3L);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}/count&quot;, usuarioId))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).value(3));&#10;&#10;        verify(disenoService).contarDisenosPorUsuario(usuarioId);&#10;    }&#10;&#10;    @Test&#10;    void contarDisenosPorUsuarioYEstado_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(disenoService.contarDisenosPorUsuarioYEstado(usuarioId, DisenoStatus.PROGRESO))&#10;                .thenReturn(2L);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/disenos/usuario/{usuarioId}/count/{status}&quot;,&#10;                        usuarioId, &quot;PROGRESO&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).value(2));&#10;&#10;        verify(disenoService).contarDisenosPorUsuarioYEstado(usuarioId, DisenoStatus.PROGRESO);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/TipoBolsaControllerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/TipoBolsaControllerTest.java" />
              <option name="originalContent" value="import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.paper.controller.TipoBolsaController;&#10;import org.paper.dtoCreate.TipoBolsaCreateDto;&#10;import org.paper.dtoCreate.TipoBolsaUpdateDto;&#10;import org.paper.dtoResponse.TipoBolsaResponseDto;&#10;import org.paper.service.TipoBolsaService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;&#10;import org.springframework.boot.test.mock.mockito.MockBean;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;import org.springframework.test.context.ContextConfiguration;&#10;&#10;import java.util.Arrays;&#10;import java.util.Collections;&#10;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.eq;&#10;import static org.mockito.Mockito.*;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@WebMvcTest(TipoBolsaController.class)&#10;@ContextConfiguration(classes = org.paper.Main.class)&#10;class TipoBolsaControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    @MockBean&#10;    private TipoBolsaService tipoBolsaService;&#10;&#10;    private TipoBolsaResponseDto tipoBolsaResponseDto;&#10;    private TipoBolsaCreateDto tipoBolsaCreateDto;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        tipoBolsaResponseDto = TipoBolsaResponseDto.builder()&#10;                .id(1)&#10;                .nombre(&quot;Bolsa con Asa&quot;)&#10;                .build();&#10;&#10;        tipoBolsaCreateDto = new TipoBolsaCreateDto();&#10;        tipoBolsaCreateDto.setNombre(&quot;Bolsa Sin Asa&quot;);&#10;    }&#10;&#10;    @Test&#10;    void obtenerTiposBolsas_DeberiaRetornar200ConLista() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.findAll())&#10;                .thenReturn(Arrays.asList(tipoBolsaResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isArray())&#10;                .andExpect(jsonPath(&quot;$.data[0].nombre&quot;).value(&quot;Bolsa con Asa&quot;))&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 1 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).findAll();&#10;    }&#10;&#10;    @Test&#10;    void obtenerTiposBolsas_DeberiaRetornar200ConListaVacia() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.findAll()).thenReturn(Collections.emptyList());&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isArray())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isEmpty())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 0 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).findAll();&#10;    }&#10;&#10;    @Test&#10;    void obtenerTipoBolsaPorId_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.findById(1)).thenReturn(tipoBolsaResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa/{id}&quot;, 1))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data.id&quot;).value(1))&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Bolsa con Asa&quot;));&#10;&#10;        verify(tipoBolsaService).findById(1);&#10;    }&#10;&#10;    @Test&#10;    void crearTipoBolsa_DeberiaRetornar201() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.save(any(TipoBolsaCreateDto.class)))&#10;                .thenReturn(tipoBolsaResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(post(&quot;/api/tipos-bolsa&quot;)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(tipoBolsaCreateDto)))&#10;                .andExpect(status().isCreated())&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Bolsa con Asa&quot;))&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Tipo de bolsa creado exitosamente&quot;));&#10;&#10;        verify(tipoBolsaService).save(any(TipoBolsaCreateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void crearTipoBolsa_DeberiaRetornar400CuandoNombreVacio() throws Exception {&#10;        // Arrange&#10;        TipoBolsaCreateDto dtoInvalido = new TipoBolsaCreateDto();&#10;        dtoInvalido.setNombre(&quot;&quot;); // Nombre vacío&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(post(&quot;/api/tipos-bolsa&quot;)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(dtoInvalido)))&#10;                .andExpect(status().isBadRequest());&#10;&#10;        verify(tipoBolsaService, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    void actualizarTipoBolsa_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        TipoBolsaUpdateDto updateDto = new TipoBolsaUpdateDto();&#10;        updateDto.setNombre(&quot;Bolsa Americana&quot;);&#10;&#10;        when(tipoBolsaService.update(eq(1), any(TipoBolsaUpdateDto.class)))&#10;                .thenReturn(tipoBolsaResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(put(&quot;/api/tipos-bolsa/{id}&quot;, 1)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(updateDto)))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Tipo de bolsa actualizado exitosamente&quot;));&#10;&#10;        verify(tipoBolsaService).update(eq(1), any(TipoBolsaUpdateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void eliminarTipoBolsa_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        doNothing().when(tipoBolsaService).deleteById(1);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(delete(&quot;/api/tipos-bolsa/{id}&quot;, 1))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Tipo de bolsa eliminado exitosamente&quot;));&#10;&#10;        verify(tipoBolsaService).deleteById(1);&#10;    }&#10;&#10;    @Test&#10;    void buscarTiposBolsa_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.searchByNombre(&quot;asa&quot;))&#10;                .thenReturn(Arrays.asList(tipoBolsaResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa/search&quot;)&#10;                        .param(&quot;nombre&quot;, &quot;asa&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data[0].nombre&quot;).value(&quot;Bolsa con Asa&quot;))&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 1 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).searchByNombre(&quot;asa&quot;);&#10;    }&#10;&#10;    @Test&#10;    void buscarTiposBolsa_DeberiaRetornar200ConListaVacia() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.searchByNombre(&quot;noexiste&quot;))&#10;                .thenReturn(Collections.emptyList());&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa/search&quot;)&#10;                        .param(&quot;nombre&quot;, &quot;noexiste&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isEmpty())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 0 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).searchByNombre(&quot;noexiste&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.paper.controller.TipoBolsaController;&#10;import org.paper.dtoCreate.TipoBolsaCreateDto;&#10;import org.paper.dtoCreate.TipoBolsaUpdateDto;&#10;import org.paper.dtoResponse.TipoBolsaResponseDto;&#10;import org.paper.service.TipoBolsaService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;&#10;import org.springframework.boot.test.mock.mockito.MockBean;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;import org.springframework.test.context.ContextConfiguration;&#10;&#10;import java.util.Collections;&#10;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.eq;&#10;import static org.mockito.Mockito.*;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@WebMvcTest(TipoBolsaController.class)&#10;@ContextConfiguration(classes = org.paper.Main.class)&#10;class TipoBolsaControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @Autowired&#10;    private ObjectMapper objectMapper;&#10;&#10;    @MockBean&#10;    private TipoBolsaService tipoBolsaService;&#10;&#10;    private TipoBolsaResponseDto tipoBolsaResponseDto;&#10;    private TipoBolsaCreateDto tipoBolsaCreateDto;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        tipoBolsaResponseDto = TipoBolsaResponseDto.builder()&#10;                .id(1)&#10;                .nombre(&quot;Bolsa con Asa&quot;)&#10;                .build();&#10;&#10;        tipoBolsaCreateDto = new TipoBolsaCreateDto();&#10;        tipoBolsaCreateDto.setNombre(&quot;Bolsa Sin Asa&quot;);&#10;    }&#10;&#10;    @Test&#10;    void obtenerTiposBolsas_DeberiaRetornar200ConLista() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.findAll())&#10;                .thenReturn(Collections.singletonList(tipoBolsaResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isArray())&#10;                .andExpect(jsonPath(&quot;$.data[0].nombre&quot;).value(&quot;Bolsa con Asa&quot;))&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 1 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).findAll();&#10;    }&#10;&#10;    @Test&#10;    void obtenerTiposBolsas_DeberiaRetornar200ConListaVacia() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.findAll()).thenReturn(Collections.emptyList());&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isArray())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isEmpty())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 0 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).findAll();&#10;    }&#10;&#10;    @Test&#10;    void obtenerTipoBolsaPorId_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.findById(1)).thenReturn(tipoBolsaResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa/{id}&quot;, 1))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data.id&quot;).value(1))&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Bolsa con Asa&quot;));&#10;&#10;        verify(tipoBolsaService).findById(1);&#10;    }&#10;&#10;    @Test&#10;    void crearTipoBolsa_DeberiaRetornar201() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.save(any(TipoBolsaCreateDto.class)))&#10;                .thenReturn(tipoBolsaResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(post(&quot;/api/tipos-bolsa&quot;)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(tipoBolsaCreateDto)))&#10;                .andExpect(status().isCreated())&#10;                .andExpect(jsonPath(&quot;$.data.nombre&quot;).value(&quot;Bolsa con Asa&quot;))&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Tipo de bolsa creado exitosamente&quot;));&#10;&#10;        verify(tipoBolsaService).save(any(TipoBolsaCreateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void crearTipoBolsa_DeberiaRetornar400CuandoNombreVacio() throws Exception {&#10;        // Arrange&#10;        TipoBolsaCreateDto dtoInvalido = new TipoBolsaCreateDto();&#10;        dtoInvalido.setNombre(&quot;&quot;); // Nombre vacío&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(post(&quot;/api/tipos-bolsa&quot;)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(dtoInvalido)))&#10;                .andExpect(status().isBadRequest());&#10;&#10;        verify(tipoBolsaService, never()).save(any());&#10;    }&#10;&#10;    @Test&#10;    void actualizarTipoBolsa_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        TipoBolsaUpdateDto updateDto = new TipoBolsaUpdateDto();&#10;        updateDto.setNombre(&quot;Bolsa Americana&quot;);&#10;&#10;        when(tipoBolsaService.update(eq(1), any(TipoBolsaUpdateDto.class)))&#10;                .thenReturn(tipoBolsaResponseDto);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(put(&quot;/api/tipos-bolsa/{id}&quot;, 1)&#10;                        .contentType(MediaType.APPLICATION_JSON)&#10;                        .content(objectMapper.writeValueAsString(updateDto)))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Tipo de bolsa actualizado exitosamente&quot;));&#10;&#10;        verify(tipoBolsaService).update(eq(1), any(TipoBolsaUpdateDto.class));&#10;    }&#10;&#10;    @Test&#10;    void eliminarTipoBolsa_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        doNothing().when(tipoBolsaService).deleteById(1);&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(delete(&quot;/api/tipos-bolsa/{id}&quot;, 1))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Tipo de bolsa eliminado exitosamente&quot;));&#10;&#10;        verify(tipoBolsaService).deleteById(1);&#10;    }&#10;&#10;    @Test&#10;    void buscarTiposBolsa_DeberiaRetornar200() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.searchByNombre(&quot;asa&quot;))&#10;                .thenReturn(Collections.singletonList(tipoBolsaResponseDto));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa/search&quot;)&#10;                        .param(&quot;nombre&quot;, &quot;asa&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data[0].nombre&quot;).value(&quot;Bolsa con Asa&quot;))&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 1 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).searchByNombre(&quot;asa&quot;);&#10;    }&#10;&#10;    @Test&#10;    void buscarTiposBolsa_DeberiaRetornar200ConListaVacia() throws Exception {&#10;        // Arrange&#10;        when(tipoBolsaService.searchByNombre(&quot;noexiste&quot;))&#10;                .thenReturn(Collections.emptyList());&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/tipos-bolsa/search&quot;)&#10;                        .param(&quot;nombre&quot;, &quot;noexiste&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.data&quot;).isEmpty())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).value(&quot;Se encontraron 0 tipos de bolsa&quot;));&#10;&#10;        verify(tipoBolsaService).searchByNombre(&quot;noexiste&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>